{% extends "base_htmls/base.html" %}
{% block title %}
<title>Note-itâ„¢ | Public Notes</title>

{% endblock %}

{% block content %}

<div class="content">

    <h1><i class="far fa-clone"></i> Public Notes <small class="text-muted">shared notes</small></h1>

</div>

<hr class="my-4">

<div class="list-group">


    <form class="form-row my-2 my-lg-0" method="POST">
        <div class="col">
            {% if form %}
            <input class="form-control mr-sm-2" type="search" placeholder="Search Author name, title and content!" aria-label="Search" id="Search_note" name="Search_note" value="{{ form }}" v-model="query">
            {% else %}
            <input class="form-control mr-sm-2" type="search" placeholder="Search Author name, title and content!" aria-label="Search" id="Search_note" name="Search_note" value="{{ form }}" v-model="query">
            {% endif %}

        </div>
        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
    </form>

    <br>

    {% if notes == [] or notes == None %}

    <div class="alert alert-primary" role="alert">
        <i class="far fa-frown"></i> There are no shared notes.
    </div>

    {% endif %}

    {% for note in notes %}

    <a href="{{ url_for('notes.note', note_id=note._id) }}" class="list-group-item list-group-item-action flex-column align-items-start">
        <div class="d-flex w-100 justify-content-between">
            <h2 class="mb-1"><i class="fas fa-sticky-note"></i> {{ note.title }}</h2>
            <p class="list-group-item-text">Author: {{ note.author_nickname }}</p>
        </div>

        <div class="d-flex w-100 justify-content-between">
            <p class="mb-1"></p>
            <p class="list-group-item-text">Created date: {{ note.created_date.strftime("%Y-%m-%d at %H:%M") }}</p>
        </div>

    </a>

    {% endfor %}

</div>
<div class="row">
        <div class="col-md-3" v-for="result in results">
            <div class="panel panel-default">
                <div class="panel-heading">
                <!-- display the city name and country  -->
                    {% raw %}{{ result._source.name }}, {{ result._source.country }}
                </div>
                <div class="panel-body">
                <!-- display the latitude and longitude of the city  -->
                    <p>lat:{{ result._source.lat }}, long: {{ result._source.lng }}.</p>
                    {% endraw %}
                </div>
            </div>
        </div>
    </div>

<script>
//template2.html
// instantiate a new Elasticsearch client like you did on the client
var client = new elasticsearch.Client({
    hosts: ['http://127.0.0.1:9200']
});
//require Express
const express = require(['express']);
// instanciate an instance of express and hold the value in a constant called app
const app     = express();
//require the body-parser library. will be used for parsing body requests
const bodyParser = require(['body-parser']);
//require the path library
const path    = require( ['path'] );

// ping the client to be sure Elasticsearch is up
client.ping({
     requestTimeout: 30000,
 }, function(error) {
 // at this point, eastic search is down, please check your Elasticsearch service
     if (error) {
         console.error('elasticsearch cluster is down!');
     } else {
         console.log('Everything is ok');
     }
 });


// use the bodyparser as a middleware
app.use(bodyParser.json())
// set port for the app to listen on
app.set( 'port', process.env.PORT || 3001 );
// set path to serve static files
app.use( express.static( path.join( __dirname, 'public' )));
// enable CORS
app.use(function(req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS');
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
  next();
});

// defined the base route and return with an HTML file called tempate.html
app.get('/', function(req, res){
  res.sendFile('template.html', {
     root: path.join( __dirname, 'views' )
   });
})

// define the /search route that should return elastic search results
app.get('/search', function (req, res){
  // declare the query object to search elastic search and return only 200 results from the first result found.
  // also match any data where the name is like the query string sent in
  let body = {
    size: 200,
    from: 0,
    query: {
      match: {
          name: req.query['q']
      }
    }
  }
  // perform the actual search passing in the index, the search query and the type
  client.search({index:'scotch.io-tutorial',  body:body, type:'cities_list'})
  .then(results => {
    res.send(results.hits.hits);
  })
  .catch(err=>{
    console.log(err)
    res.send([]);
  });

})
// listen on the specified port
app .listen( app.get( 'port' ), function(){
  console.log( 'Express server listening on port ' + app.get( 'port' ));
} );


// create a new Vue instance
var app2 = new Vue({
    el: '#app',
    // declare the data for the component (An array that houses the results and a query that holds the current search string)
    data: {
        results: [],
        query: ''
    },
    // declare methods in this Vue component. here only one method which performs the search is defined
    methods: {
        // function that calls the elastic search. here the query object is set just as that of the server.
        //Here the query string is passed directly from Vue
        search: function() {
            var body = {
                    size: 200,
                    from: 0,
                    query: {
                        match: {
                            name: this.query
                        }
                    }
                }
                // search the Elasticsearch passing in the index, query object and type
            client.search({ index: 'scotch.io-tutorial', body: body, type: 'cities_list' })
                .then(results => {
                    console.log(`found ${results.hits.total} items in ${results.took}ms`);
                    // set the results to the result array we have
                    this.results = results.hits.hits;
                })
                .catch(err => {
                    console.log(err)

                });


        }
    },
    // declare Vue watchers
    watch: {
        // watch for change in the query string and recall the search method
        query: function() {
            this.search();
        }
    }

})</script>


{% endblock %}